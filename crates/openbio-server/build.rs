fn main() {
    // Trigger rebuild when migrations or schema change
    println!("cargo:rerun-if-changed=../../database/schema.prisma");
    println!("cargo:rerun-if-changed=../../database/migrations");

    // Add workspace node_modules/.bin to PATH so prisma CLI can be found
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let path_env = std::env::var("PATH").unwrap_or_default();
    let node_modules_bin = std::path::Path::new(&manifest_dir).join("../../node_modules/.bin");

    // Canonicalize to ensure absolute path if possible, but fallback to naive join
    let node_modules_bin_path = node_modules_bin.canonicalize().unwrap_or(node_modules_bin);

    if node_modules_bin_path.exists() {
        let new_path = format!("{}:{}", node_modules_bin_path.display(), path_env);
        std::env::set_var("PATH", new_path);
    }

    println!("cargo:warning=BUILD SCRIPT RUNNING");
    println!(
        "cargo:warning=PATH: {}",
        std::env::var("PATH").unwrap_or_default()
    );

    // Set schema path for prisma-client-rust
    let schema_path = std::path::Path::new(&manifest_dir).join("../../database/schema.prisma");
    std::env::set_var("PRISMA_SCHEMA_PATH", schema_path);

    // Execute the Prisma generator
    prisma_client_rust_cli::run();

    // Auto-generate migrations module from database/migrations directory
    generate_migrations_module();
}

fn generate_migrations_module() {
    use std::fs;
    use std::path::Path;

    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let migrations_dir = Path::new(&manifest_dir).join("../../database/migrations");
    let output_file = Path::new(&manifest_dir).join("src/db/migrations.rs");

    // Check if migrations directory exists
    if !migrations_dir.exists() {
        eprintln!("No migrations directory found at {:?}", migrations_dir);
        return;
    }

    // Read all migration directories
    let mut migrations = Vec::new();
    if let Ok(entries) = fs::read_dir(&migrations_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                let migration_name = path.file_name().unwrap().to_string_lossy().to_string();
                // Skip migration_lock.toml and other non-migration files
                if migration_name.starts_with(char::is_numeric) {
                    let sql_file = path.join("migration.sql");
                    if sql_file.exists() {
                        migrations.push(migration_name);
                    }
                }
            }
        }
    }

    // Sort migrations by name (which includes timestamp)
    migrations.sort();

    // Generate the migrations.rs file
    let mut code = String::from(
        r#"/// Auto-generated migrations module
/// DO NOT EDIT MANUALLY - Generated by build.rs

use super::prisma::PrismaClient;
use std::collections::HashMap;

/// Migration metadata
#[derive(Debug)]
struct Migration {
    name: String,
    sql: &'static str,
}

/// Get all embedded migrations
fn get_migrations() -> Vec<Migration> {
    vec![
"#,
    );

    for migration in &migrations {
        code.push_str(&format!(
            r#"        Migration {{
            name: "{}".to_string(),
            sql: include_str!("../../../../database/migrations/{}/migration.sql"),
        }},
"#,
            migration, migration
        ));
    }

    code.push_str(
        r####"    ]
}

/// Get database path from Prisma client URL
/// Extracts the file path from URLs like "file:./openbio.db" or "file:/path/to/db.db"
fn get_db_path_from_client(client: &PrismaClient) -> anyhow::Result<String> {
    // The client stores the connection string internally
    // For SQLite, we need to extract the file path
    // This is a workaround - ideally we'd get it from the client directly
    
    // Try environment variables first
    if let Ok(url) = std::env::var("DATABASE_URL") {
        return Ok(url.trim_start_matches("file:").to_string());
    }
    if let Ok(url) = std::env::var("PRISMA_DATABASE_URL") {
        return Ok(url.trim_start_matches("file:").to_string());
    }
    
    // This should match what was passed to PrismaClient::_builder().with_url()
    // but we need a better way to get it. For now, use default location.
    Ok("./openbio.db".to_string())
}

/// Initialize or update the database schema
/// This applies all pending migrations in order
pub async fn apply_migrations(client: &PrismaClient, db_url: &str) -> anyhow::Result<()> {
    use rusqlite::Connection;
    
    // Extract file path from URL (remove "file:" prefix)
    let db_path = db_url.trim_start_matches("file:").trim_start_matches("//");
    
    tracing::info!("Opening direct SQLite connection to: {}", db_path);
    
    // Open direct SQLite connection for DDL operations
    let conn = Connection::open(db_path)
        .map_err(|e| anyhow::anyhow!("Failed to open SQLite connection to {}: {}", db_path, e))?;
    
    // Create migration tracking table if it doesn't exist
    conn.execute(
        r#"CREATE TABLE IF NOT EXISTS "_prisma_migrations" (
            "id" TEXT NOT NULL PRIMARY KEY,
            "checksum" TEXT NOT NULL,
            "finished_at" DATETIME,
            "migration_name" TEXT NOT NULL,
            "logs" TEXT,
            "rolled_back_at" DATETIME,
            "started_at" DATETIME NOT NULL DEFAULT current_timestamp,
            "applied_steps_count" INTEGER NOT NULL DEFAULT 0
        )"#,
        [],
    )?;
    
    // Get list of applied migrations
    let mut stmt = conn.prepare(
        "SELECT migration_name FROM _prisma_migrations WHERE finished_at IS NOT NULL"
    )?;
    
    let applied_migrations: Vec<String> = stmt
        .query_map([], |row| row.get(0))?
        .collect::<Result<Vec<_>, _>>()?;
    
    let applied: HashMap<String, bool> = applied_migrations
        .into_iter()
        .map(|name| (name, true))
        .collect();
    
    // Apply pending migrations in order
    for migration in get_migrations() {
        if applied.contains_key(&migration.name) {
            tracing::debug!("Migration {} already applied, skipping", migration.name);
            continue;
        }
        
        tracing::info!("Applying migration: {}", migration.name);
        
        let migration_id = uuid::Uuid::new_v4().to_string();
        let checksum = calculate_checksum(migration.sql);
        
        // Start migration record
        conn.execute(
            "INSERT INTO _prisma_migrations (id, checksum, migration_name, logs, started_at) VALUES (?1, ?2, ?3, '', datetime('now'))",
            [&migration_id, &checksum, &migration.name],
        )?;
        
        // Execute migration SQL
        conn.execute_batch(migration.sql)
            .map_err(|e| {
                anyhow::anyhow!(
                    "Failed to execute migration {}: {}",
                    migration.name,
                    e
                )
            })?;
        
        // Mark migration as complete
        conn.execute(
            "UPDATE _prisma_migrations SET finished_at = datetime('now'), applied_steps_count = 1 WHERE migration_name = ?1",
            [&migration.name],
        )?;
        
        tracing::info!("Migration {} applied successfully", migration.name);
    }
    
    tracing::info!("All migrations applied successfully");
    Ok(())
}

fn calculate_checksum(content: &str) -> String {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    
    let mut hasher = DefaultHasher::new();
    content.hash(&mut hasher);
    format!("{:x}", hasher.finish())
}
"####,
    );

    fs::write(&output_file, code).expect("Failed to write migrations.rs");
    println!(
        "cargo:warning=Generated {} migrations in migrations.rs",
        migrations.len()
    );
}
