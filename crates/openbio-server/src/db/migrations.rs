/// Auto-generated migrations module
/// DO NOT EDIT MANUALLY - Generated by build.rs

use super::prisma::PrismaClient;
use std::collections::HashMap;

/// Migration metadata
#[derive(Debug)]
struct Migration {
    name: String,
    sql: &'static str,
}

/// Get all embedded migrations
fn get_migrations() -> Vec<Migration> {
    vec![
        Migration {
            name: "20260127023127_init".to_string(),
            sql: include_str!("../../../../database/migrations/20260127023127_init/migration.sql"),
        },
    ]
}

/// Get database path from Prisma client URL
/// Extracts the file path from URLs like "file:./openbio.db" or "file:/path/to/db.db"
fn get_db_path_from_client(client: &PrismaClient) -> anyhow::Result<String> {
    // The client stores the connection string internally
    // For SQLite, we need to extract the file path
    // This is a workaround - ideally we'd get it from the client directly
    
    // Try environment variables first
    if let Ok(url) = std::env::var("DATABASE_URL") {
        return Ok(url.trim_start_matches("file:").to_string());
    }
    if let Ok(url) = std::env::var("PRISMA_DATABASE_URL") {
        return Ok(url.trim_start_matches("file:").to_string());
    }
    
    // This should match what was passed to PrismaClient::_builder().with_url()
    // but we need a better way to get it. For now, use default location.
    Ok("./openbio.db".to_string())
}

/// Initialize or update the database schema
/// This applies all pending migrations in order
pub async fn apply_migrations(client: &PrismaClient, db_url: &str) -> anyhow::Result<()> {
    use rusqlite::Connection;
    
    // Extract file path from URL (remove "file:" prefix)
    let db_path = db_url.trim_start_matches("file:").trim_start_matches("//");
    
    tracing::info!("Opening direct SQLite connection to: {}", db_path);
    
    // Open direct SQLite connection for DDL operations
    let conn = Connection::open(db_path)
        .map_err(|e| anyhow::anyhow!("Failed to open SQLite connection to {}: {}", db_path, e))?;
    
    // Create migration tracking table if it doesn't exist
    conn.execute(
        r#"CREATE TABLE IF NOT EXISTS "_prisma_migrations" (
            "id" TEXT NOT NULL PRIMARY KEY,
            "checksum" TEXT NOT NULL,
            "finished_at" DATETIME,
            "migration_name" TEXT NOT NULL,
            "logs" TEXT,
            "rolled_back_at" DATETIME,
            "started_at" DATETIME NOT NULL DEFAULT current_timestamp,
            "applied_steps_count" INTEGER NOT NULL DEFAULT 0
        )"#,
        [],
    )?;
    
    // Get list of applied migrations
    let mut stmt = conn.prepare(
        "SELECT migration_name FROM _prisma_migrations WHERE finished_at IS NOT NULL"
    )?;
    
    let applied_migrations: Vec<String> = stmt
        .query_map([], |row| row.get(0))?
        .collect::<Result<Vec<_>, _>>()?;
    
    let applied: HashMap<String, bool> = applied_migrations
        .into_iter()
        .map(|name| (name, true))
        .collect();
    
    // Apply pending migrations in order
    for migration in get_migrations() {
        if applied.contains_key(&migration.name) {
            tracing::debug!("Migration {} already applied, skipping", migration.name);
            continue;
        }
        
        tracing::info!("Applying migration: {}", migration.name);
        
        let migration_id = uuid::Uuid::new_v4().to_string();
        let checksum = calculate_checksum(migration.sql);
        
        // Start migration record
        conn.execute(
            "INSERT INTO _prisma_migrations (id, checksum, migration_name, logs, started_at) VALUES (?1, ?2, ?3, '', datetime('now'))",
            [&migration_id, &checksum, &migration.name],
        )?;
        
        // Execute migration SQL
        conn.execute_batch(migration.sql)
            .map_err(|e| {
                anyhow::anyhow!(
                    "Failed to execute migration {}: {}",
                    migration.name,
                    e
                )
            })?;
        
        // Mark migration as complete
        conn.execute(
            "UPDATE _prisma_migrations SET finished_at = datetime('now'), applied_steps_count = 1 WHERE migration_name = ?1",
            [&migration.name],
        )?;
        
        tracing::info!("Migration {} applied successfully", migration.name);
    }
    
    tracing::info!("All migrations applied successfully");
    Ok(())
}

fn calculate_checksum(content: &str) -> String {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    
    let mut hasher = DefaultHasher::new();
    content.hash(&mut hasher);
    format!("{:x}", hasher.finish())
}
